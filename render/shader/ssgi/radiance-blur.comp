#version 460

#extension GL_GOOGLE_include_directive : enable
#include "../common/gbuffer-storage.glsl"

layout(local_size_x = 16, local_size_y = 16) in;

layout(set = 0, binding = 0) uniform sampler2D in_radiance_tex;
layout(set = 0, binding = 1) uniform sampler2D depth_tex;
layout(set = 0, binding = 2) uniform sampler2D albedo_tex;
layout(set = 0, binding = 3) uniform usampler2D lighting_info_tex;

layout(set = 1, binding = 0, rgba16f) uniform writeonly image2D out_radiance_tex;

layout(std140, set = 2, binding = 0) uniform Params
{
    vec4 inv_proj_mat_col3;
    vec4 inv_proj_mat_col4;
    uvec2 resolution;
};

const float NORMAL_SIGMA = 5;
const float NORMAL_THRES = 0.8;
const float DEPTH_SIGMA = 10;
const float ALBEDO_SIGMA = 7;
const float ROUGHNESS_METALNESS_SIGMA = 5;
const float BLUR_SIGMA = 2;

float normal_similarity(vec3 n1, vec3 n2)
{
    const float dot_product = max(dot(n1, n2), 0.0);
    return pow(dot_product * step(NORMAL_THRES, dot_product), NORMAL_SIGMA);
}

float depth_similarity(float d1, float d2)
{
    const float max_depth = max(d1, d2);
    const float min_depth = min(d1, d2);
    const float ratio = (max_depth - min_depth) / max_depth;
    return exp(-ratio * DEPTH_SIGMA);
}

float albedo_similarity(vec3 a1, vec3 a2)
{
    return exp(-distance(a1, a2) * ALBEDO_SIGMA);
}

float roughness_metalness_similarity(float r1, float r2, float m1, float m2)
{
    return exp((-distance(r1, r2) - distance(m1, m2)) * ROUGHNESS_METALNESS_SIGMA);
}

const ivec2 offsets[25] = {
        ivec2(0, 0),
        ivec2(0, -1),
        ivec2(0, 1),
        ivec2(-1, 1),
        ivec2(-1, 0),
        ivec2(-1, -1),
        ivec2(1, -1),
        ivec2(1, 0),
        ivec2(1, 1),
        ivec2(-2, -2),
        ivec2(-2, -1),
        ivec2(-2, 0),
        ivec2(-2, 1),
        ivec2(-2, 2),
        ivec2(-1, -2),
        ivec2(-1, 2),
        ivec2(0, -2),
        ivec2(0, 2),
        ivec2(1, -2),
        ivec2(1, 2),
        ivec2(2, -2),
        ivec2(2, -1),
        ivec2(2, 0),
        ivec2(2, 1),
        ivec2(2, 2),
    };

// pad shared tile to accommodate local_size (16) + 2px border on each side -> 20
shared vec4 shared_normals_roughness[20][20]; // RGB: normals, A: roughness
shared vec4 shared_metalness_radiance[20][20]; // R: metalness, GBA: Radiance
shared vec4 shared_albedo_depth[20][20]; // RGB: albedo, A: depth

// helper: fetch one texel from the full-res inputs and store into shared arrays
void prefetch_store(ivec2 dst_index, ivec2 src_coord)
{
    const ivec2 full_coord = src_coord << 1;

    const uvec4 prefetch_lighting_info = texelFetch(lighting_info_tex, full_coord, 0);
    const vec4 prefetch_albedo = texelFetch(albedo_tex, full_coord, 0);
    const vec4 prefetch_depth = texelFetch(depth_tex, full_coord, 0);
    const vec4 prefetch_radiance = texelFetch(in_radiance_tex, src_coord, 0);

    const GBufferLighting prefetch_lighting = unpack_gbuffer_lighting(prefetch_lighting_info.xy);

    shared_normals_roughness[dst_index.y][dst_index.x] = vec4(prefetch_lighting.normal, prefetch_lighting.roughness);
    shared_metalness_radiance[dst_index.y][dst_index.x] = vec4(prefetch_lighting.metalness, prefetch_radiance.rgb);
    shared_albedo_depth[dst_index.y][dst_index.x] = vec4(prefetch_albedo.rgb, prefetch_depth.r);
}

void main()
{
    /* Prefetch */

    const ivec2 local_coord = ivec2(gl_LocalInvocationID.xy);
    const ivec2 screen_coord = ivec2(gl_GlobalInvocationID.xy);
    const ivec2 workgroup_id = ivec2(gl_WorkGroupID.xy);
    const ivec2 workgroup_coord = workgroup_id << 4; // * 16
    const ivec2 full_coord = screen_coord << 1;
    const ivec2 prefetch_half_coord = workgroup_coord + (local_coord << 1) - 2;

    if (all(lessThan(local_coord, ivec2(10))))
    {
        const ivec2 block_offset = local_coord * 2;

        // fetch and store the four texels for this thread's 2x2 tile
        prefetch_store(block_offset + ivec2(0, 0), prefetch_half_coord + ivec2(0, 0));
        prefetch_store(block_offset + ivec2(1, 0), prefetch_half_coord + ivec2(1, 0));
        prefetch_store(block_offset + ivec2(0, 1), prefetch_half_coord + ivec2(0, 1));
        prefetch_store(block_offset + ivec2(1, 1), prefetch_half_coord + ivec2(1, 1));
    }

    barrier();

    /* Compute */

    if (any(greaterThanEqual(screen_coord, ivec2(resolution)))) return;

    float depth = texelFetch(depth_tex, full_coord, 0).r;
    const GBufferLighting curr_lighting = unpack_gbuffer_lighting(
            texelFetch(lighting_info_tex, full_coord, 0).xy
        );
    const vec3 curr_albedo = texelFetch(albedo_tex, full_coord, 0).rgb;

    if (depth == 0.0)
    {
        imageStore(out_radiance_tex, screen_coord, vec4(0.0));
        return;
    }

    vec3 total_weighted_radiance = vec3(0.0);
    float total_weight = 0.0;

    for (int i = 0; i < 25; i++)
    {
        const ivec2 offset = offsets[i];
        const ivec2 neighbor_half_coord = screen_coord + offset;
        const ivec2 prefetch_coord = local_coord + offset + 2;

        bool out_of_bound = any(lessThan(neighbor_half_coord, ivec2(0))) ||
                any(greaterThanEqual(neighbor_half_coord, ivec2(resolution)));

        if (out_of_bound) continue;

        const vec4 neighbor_normal_roughness = shared_normals_roughness[prefetch_coord.y][prefetch_coord.x];
        const vec4 neighbor_metalness_radiance = shared_metalness_radiance[prefetch_coord.y][prefetch_coord.x];
        const vec4 neighbor_albedo_depth = shared_albedo_depth[prefetch_coord.y][prefetch_coord.x];

        const float n_sim = normal_similarity(curr_lighting.normal, neighbor_normal_roughness.xyz);
        const float d_sim = depth_similarity(depth, neighbor_albedo_depth.w);
        const float a_sim = albedo_similarity(curr_albedo, neighbor_albedo_depth.rgb);
        const float rm_sim = roughness_metalness_similarity(
                curr_lighting.roughness,
                neighbor_normal_roughness.w,
                curr_lighting.metalness,
                neighbor_metalness_radiance.x
            );

        const vec2 real_offset = vec2(offset);
        const float positional_weight = exp(-dot(real_offset, real_offset) / (2 * BLUR_SIGMA * BLUR_SIGMA));
        float weight = (positional_weight * n_sim) * (d_sim * a_sim) * (rm_sim);

        if (isnan(weight) || isinf(weight)) weight = 0.0;

        total_weighted_radiance += neighbor_metalness_radiance.gba * weight;
        total_weight += weight;
    }

    // guard division for safety (shouldn't happen in normal operation)
    vec3 blurred_radiance = (total_weight > 0.0) ? (total_weighted_radiance / total_weight) : texelFetch(in_radiance_tex, screen_coord, 0).rgb;
    blurred_radiance = clamp(blurred_radiance, vec3(0.0), vec3(65504.0));

    imageStore(out_radiance_tex, screen_coord, vec4(blurred_radiance, 1.0));
}
